2025.11.3
	该目录的主要作用在于给卡顿区间的划分设定一个统一标准，以确保多人参与在区间划分工作时，能够实现一致标准。
	我们目前有3个场景：游戏、视频、会议。在具体划分上则主要是2个分类：
		游戏：观测游戏延时；
		视频和会议：观测回传画面(画面中显示实时北京时间)和本机时间是否流畅匹配。
	我们将从2个方向展开标准：

游戏：观测游戏延时
	主要关注3个指标：
		本机时间：由时间悬浮框APP提供，提供毫秒级本机时间，是卡顿区间划分的度量；
		游戏时延：最为直观的观测指标、优先级最高的观测指标，是卡顿区间划分的主要依据；
		游戏画面：是主要观测指标的验证，在游戏时延过高时提供验证，优先级较低。
	卡顿区间的划定方法：
		前提：确保“时间悬浮框”APP的时间经过了校准；
		观测：观测游戏时延，当游戏时延超过 ！！200ms  ！！时，记录为卡顿区间的开始时刻；
			   观测游戏时延，当游戏时延恢复 ！！200ms  ！！一下时，记录为卡顿区间的截至时刻。
		记录：记录开始截至时刻的时间依据是“时间悬浮框”的时间
			   记录格式：参考dataPreProcessing/readme.txt当中关于lag_timeList.txt文件的记录标准

视频，会议：观测回传画面中北京时间
	主要关注3个指标：
		本机时间：由时间悬浮框APP提供，提供毫秒级本机时间，是卡顿区间划分的度量；
		回传画面中北京时间：辅助机拍摄北京时间并传送给测试机，如果卡顿发生，那么画面回传回受阻，则画面中北京时间卡顿而不再变化，从而落后于实际的北京时间(本机时间)，该特征是我们判定卡顿发生的主要依据。
		回传画面中北京时间与本机时间的偏差：由于辅助机通过网络链路将画面传递给测试机，假设在第10秒，辅助机将画面(记录下北京时间为第10s)发送给测试机，但是网络链路延迟为0.5s，则该画面在第10.5秒才显示在测试机屏幕上，则此时测试机的北京时间是10.5s，画面是10s，则这个误差是允许的。
	卡顿区间的划定方法：
		前提：确保“时间悬浮框”APP的时间经过了校准；
		观测：在测试开始之初(或者标签工作的开展之初)，在确定网络流畅、画面稳定的前提下，记录本次测试下！！画面中北京时间与本机时间的偏差  ！！。
			   正式开始标签工作，观测回传画面中北京时间，当出现画面卡顿(肉眼可见的画面停顿)，记录为卡顿区间的开始时刻；
							    观测回传画面中北京时间，当画面卡顿恢复时，记录为卡顿区间的截至时刻；
			   对于开始截至时刻所限定的卡顿区间，在Label阶段我们要求记录下所有肉眼可见的卡顿区间，而不像此前所要求的，这一点将会在后文“特别说明”当中阐明。
		记录：记录开始截至时刻的时间依据是“时间悬浮框”的时间
			   记录格式：参考dataPreProcessing/readme.txt当中关于lag_timeList.txt文件的记录标准


特别说明：
1. 关于视频、会议当中，开始截至时刻所限定的卡顿区间我们要求记录所有肉眼可见的卡顿区间，而不再像最开始的描述：我们只记录区间长度2s以上的卡顿区间。
	此前，我们判断卡顿区间的量化标准是：如果回传时间和本机系统时间的偏差超过2s，则记录卡顿开始的时间为开始时刻、卡顿恢复的时间为截至时刻。
	一方面，这一记录方法在新的实验观测当中遇到了挑战：在部分场景下，回传时间与本机系统时间的稳定偏差就有1s了，部分场景下甚至可以2s，这对于我们记录方法提出了问题，如果稳定偏差就有2s了，那我们的卡顿区间怎么划分？如果一个场景下稳定偏差0.5s，另一个场景稳定偏差1s，那么都按照画面偏差2s来看的话，两个场景的卡顿区间划分的量化标准是否一致呢？
	另一方面，“卡顿区间2s以上的”这一内容是可以抽象的，是可以单独抽象为lag_timeList.txt文件处理中的一层——过滤层，我们可以尽可能详细地记录卡顿区间，然后经过过滤层来获取我们需要的区间，这样具有更好的灵活性。
